<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>üöÄ Space Shooter Deluxe - Revamped</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #000;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
      color: #0ff;
      user-select: none;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      height: 100vh;
    }
    #game-container {
      position: relative;
      margin-top: 10px;
    }
    canvas {
      display: block;
      border: 5px solid #00ffcc;
      background: radial-gradient(ellipse at center, #000 0%, #030303 100%);
      touch-action: none;
      background-size: cover;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      text-align: left;
      font-size: 18px;
      color: #0ff;
      text-shadow: 1px 1px 2px #000;
      user-select: none;
      width: 180px;
      z-index: 10;
      line-height: 1.5;
    }
    #pauseMsg {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #0ff;
      font-size: 36px;
      text-shadow: 2px 2px 5px #000;
      display: none;
      user-select: none;
      z-index: 20;
      pointer-events: none;
    }
    #retryBtn {
      position: absolute;
      top: 60%;
      left: 50%;
      transform: translateX(-50%);
      background: #00ffcc;
      border: none;
      border-radius: 10px;
      padding: 15px 40px;
      font-size: 24px;
      font-weight: bold;
      color: #000;
      cursor: pointer;
      display: none;
      z-index: 21;
      user-select: none;
    }
    #muteBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #00ffcc;
      border: none;
      border-radius: 10px;
      padding: 10px 20px;
      font-size: 16px;
      font-weight: bold;
      color: #000;
      cursor: pointer;
      user-select: none;
      z-index: 11;
    }
    #instructions {
      position: fixed;
      right: 15px;
      top: 50px;
      width: 220px;
      font-size: 16px;
      color: #0ff;
      text-shadow: 1px 1px 2px #000;
      user-select: none;
      line-height: 1.4;
      font-weight: 600;
      font-family: 'Orbitron', sans-serif;
    }
    #instructions h2 {
      margin-top: 0;
      font-size: 22px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game" width="480" height="640"></canvas>
    <div id="ui">
      <div>üöÄ Score: <span id="score">0</span></div>
      <div>‚ù§Ô∏è Health: <span id="health">3</span></div>
      <div>üåä Wave: <span id="wave">1</span></div>
      <div>üèÜ High Score: <span id="highscore">0</span></div>
    </div>
    <div id="pauseMsg">PAUSED</div>
    <button id="retryBtn">Retry</button>
    <button id="muteBtn">Mute üîä</button>
  </div>

  <div id="instructions">
    <h2>Controls</h2>
    <p><strong>Left:</strong> ‚óÄÔ∏è or A key</p>
    <p><strong>Right:</strong> ‚ñ∂Ô∏è or D key</p>
    <p><strong>Shoot:</strong> Tap Space or Z key (No holding)</p>
    <p><strong>Pause:</strong> Press P</p>
    <p><strong>Mute:</strong> Click Mute button</p>
  </div>

<script>
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  // UI Elements
  const scoreEl = document.getElementById("score");
  const healthEl = document.getElementById("health");
  const waveEl = document.getElementById("wave");
  const highscoreEl = document.getElementById("highscore");
  const pauseMsg = document.getElementById("pauseMsg");
  const retryBtn = document.getElementById("retryBtn");
  const muteBtn = document.getElementById("muteBtn");

  let keys = {};
  document.addEventListener("keydown", e => {
    keys[e.key.toLowerCase()] = true;
    if (e.key.toLowerCase() === 'p') togglePause();
    if ((e.key.toLowerCase() === ' ' || e.key.toLowerCase() === 'z') && !gameOverFlag) {
      e.preventDefault();
      player.shoot();
    }
  });
  document.addEventListener("keyup", e => {
    keys[e.key.toLowerCase()] = false;
  });

  // Game variables
  let score = 0;
  let wave = 1;
  let health = 3;
  let highscore = localStorage.getItem("spaceHighScore") || 0;
  highscoreEl.textContent = highscore;

  let paused = false;
  let gameOverFlag = false;

  // Sound setup
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  let muted = false;

  muteBtn.onclick = () => {
    muted = !muted;
    muteBtn.textContent = muted ? "Unmute üîà" : "Mute üîä";
    if (muted) audioCtx.suspend();
    else audioCtx.resume();
  };

  // Play simple beep sound
  function playSound(freq, type = 'square', duration = 0.1, volume=0.06) {
    if(muted) return;
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    osc.type = type;
    osc.frequency.value = freq;
    gainNode.gain.value = volume;
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
  }

  // More 8-bit style faster paced music
  let musicOscs = [];
  let musicGain = audioCtx.createGain();
  musicGain.connect(audioCtx.destination);
  musicGain.gain.value = 0.03;

  function playMusic() {
    if(muted) return;
    if(musicOscs.length) return; // already playing

    // Simple arpeggio synth style loop
    const notes = [523.25, 659.25, 783.99, 1046.5, 1318.5]; // C5,G5,B5,C6,E6
    let idx = 0;

    function playNext() {
      if(muted) return;
      let osc = audioCtx.createOscillator();
      osc.type = 'square';
      osc.frequency.setValueAtTime(notes[idx], audioCtx.currentTime);
      osc.connect(musicGain);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.15);
      musicOscs.push(osc);

      // Cleanup
      osc.onended = () => {
        musicOscs = musicOscs.filter(o => o !== osc);
      };

      idx = (idx + 1) % notes.length;
      setTimeout(playNext, 180);
    }
    playNext();
  }
  playMusic();

  class Player {
    constructor() {
      this.w = 36;
      this.h = 28;
      this.x = canvas.width / 2 - this.w / 2;
      this.y = canvas.height - 70;
      this.speed = 2;
      this.cooldown = 0;
      this.bullets = [];
      this.powerUp = false;
      this.powerTime = 0;
    }
    update() {
      if (!paused && !gameOverFlag) {
        if ((keys["arrowleft"] || keys["a"]) && this.x > 0) this.x -= this.speed;
        if ((keys["arrowright"] || keys["d"]) && this.x + this.w < canvas.width) this.x += this.speed;

        if (this.cooldown > 0) this.cooldown--;
        this.bullets.forEach(b => b.update());
        this.bullets = this.bullets.filter(b => b.y > -20);

        if (this.powerUp && --this.powerTime <= 0) this.powerUp = false;
      }
    }
    draw() {
      // Player ship - polygon shaped
      ctx.fillStyle = this.powerUp ? "#ff0" : "#0ff";
      ctx.beginPath();
      ctx.moveTo(this.x + this.w / 2, this.y);
      ctx.lineTo(this.x, this.y + this.h);
      ctx.lineTo(this.x + this.w, this.y + this.h);
      ctx.closePath();
      ctx.fill();

      // cockpit window
      ctx.fillStyle = "#003344";
      ctx.beginPath();
      ctx.moveTo(this.x + this.w / 2, this.y + 8);
      ctx.lineTo(this.x + 10, this.y + this.h - 5);
      ctx.lineTo(this.x + this.w - 10, this.y + this.h - 5);
      ctx.closePath();
      ctx.fill();

      this.bullets.forEach(b => b.draw());
    }
    shoot() {
      if (this.cooldown === 0 && !gameOverFlag) {
        // Bigger bullets if powered up
        const bulletW = this.powerUp ? 8 : 4;
        const bulletH = this.powerUp ? 16 : 12;
        const bulletSpeed = 5;
        this.bullets.push(new Bullet(this.x + this.w / 2 - bulletW / 2, this.y - bulletH, bulletW, bulletH, bulletSpeed));
        this.cooldown = this.powerUp ? 15 : 25; // slower fire rate
        playSound(1100, 'square', 0.08, 0.03);
      }
    }
  }

  class Bullet {
    constructor(x, y, w, h, speed) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      this.speed = speed;
    }
    update() {
      this.y -= this.speed;
    }
    draw() {
      ctx.fillStyle = "#0ff";
      ctx.fillRect(this.x, this.y, this.w, this.h);
    }
  }

  class Enemy {
    constructor(x, y, speed, hp, type = "normal") {
      this.x = x;
      this.y = y;
      this.w = 34;
      this.h = 22;
      this.speed = speed;
      this.hp = hp;
      this.type = type;
      this.dir = Math.random() < 0.5 ? -1 : 1;
      this.moveTimer = 0;
      this.shootCooldown = 0;
    }
    update() {
      if (paused || gameOverFlag) return;

      if (this.type === "fast") {
        this.y += this.speed * 1.8;
        this.x += this.dir * 1;
        this.moveTimer++;
        if(this.moveTimer % 30 === 0) this.dir *= -1;
      } else if (this.type === "shooter") {
        this.y += this.speed * 0.8;
        this.moveTimer++;
        if(this.moveTimer % 50 === 0) this.dir *= -1;
        this.x += this.dir * 0.5;
        this.shootCooldown--;
        if(this.shootCooldown <= 0) {
          enemyBullets.push(new EnemyBullet(this.x + this.w / 2 - 4, this.y + this.h, 8, 12, 3));
          this.shootCooldown = 120;
          playSound(300, 'triangle', 0.06, 0.02);
        }
      } else if (this.type === "boss") {
        this.y += this.speed * 0.4;
        this.moveTimer++;
        if(this.moveTimer % 20 === 0) this.dir *= -1;  // zigzag
        this.x += this.dir * 0.4;
      } else {
        // normal
        this.y += this.speed;
        this.moveTimer++;
        if(this.moveTimer % 30 === 0) this.dir *= -1;  // zigzag
        this.x += this.dir * 0.4;
      }

      // Stay in bounds
      if (this.x < 0) this.x = 0;
      if (this.x + this.w > canvas.width) this.x = canvas.width - this.w;
    }
    draw() {
      // Enemy shapes by type
      if(this.type === "boss") {
        ctx.fillStyle = "#f00";
        ctx.beginPath();
        ctx.moveTo(this.x + this.w / 2, this.y);
        ctx.lineTo(this.x, this.y + this.h);
        ctx.lineTo(this.x + this.w, this.y + this.h);
        ctx.closePath();
        ctx.fill();
        // Boss eye
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(this.x + this.w / 2, this.y + this.h * 0.5, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(this.x + this.w / 2, this.y + this.h * 0.5, 2, 0, Math.PI * 2);
        ctx.fill();
      } else if (this.type === "fast") {
        ctx.fillStyle = "#f90"; // orange
        ctx.beginPath();
        ctx.ellipse(this.x + this.w / 2, this.y + this.h / 2, this.w / 2, this.h / 2, 0, 0, Math.PI * 2);
        ctx.fill();
      } else if (this.type === "shooter") {
        ctx.fillStyle = "#f0f"; // magenta
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + this.w / 2, this.y + this.h);
        ctx.lineTo(this.x + this.w, this.y);
        ctx.closePath();
        ctx.fill();
      } else {
        ctx.fillStyle = "#0f0";
        ctx.beginPath();
        ctx.moveTo(this.x + this.w / 2, this.y);
        ctx.lineTo(this.x, this.y + this.h);
        ctx.lineTo(this.x + this.w, this.y + this.h);
        ctx.closePath();
        ctx.fill();
      }
    }
  }

  class EnemyBullet {
    constructor(x, y, w, h, speed) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      this.speed = speed;
    }
    update() {
      this.y += this.speed;
    }
    draw() {
      ctx.fillStyle = "#f00";
      ctx.fillRect(this.x, this.y, this.w, this.h);
    }
  }

  class PowerUp {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.r = 9;
      this.speed = 1.5;
      this.angle = 0;
    }
    update() {
      if(paused || gameOverFlag) return;
      this.y += this.speed;
      this.angle += 0.1;
    }
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.angle);
      ctx.strokeStyle = "#ff0";
      ctx.lineWidth = 3;
      ctx.beginPath();
      for(let i=0; i<5; i++) {
        ctx.lineTo(0, this.r);
        ctx.translate(0, this.r);
        ctx.rotate((Math.PI * 2 / 10));
        ctx.lineTo(0, -this.r);
        ctx.translate(0, -this.r);
        ctx.rotate(-(Math.PI * 6 / 10));
      }
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }
  }

  const player = new Player();
  let enemies = [];
  let enemyBullets = [];
  let powerUps = [];
  let waveCooldown = 0;

  function spawnWave() {
    enemies = [];
    enemyBullets = [];
    powerUps = [];
    const count = 5 + wave * 2;

    for (let i = 0; i < count; i++) {
      const x = Math.random() * (canvas.width - 34);
      const y = -Math.random() * 300 - 50;

      // Random enemy type
      const rand = Math.random();
      if (wave >= 5 && rand < 0.1) {
        enemies.push(new Enemy(x, y, 0.3 + wave * 0.05, 20, "boss"));
      } else if (rand < 0.3) {
        enemies.push(new Enemy(x, y, 1 + wave * 0.2, 1, "fast"));
      } else if (rand < 0.5) {
        enemies.push(new Enemy(x, y, 0.5 + wave * 0.1, 2, "shooter"));
      } else {
        enemies.push(new Enemy(x, y, 0.4 + wave * 0.12, 1, "normal"));
      }
    }
  }

  function updateUI() {
    scoreEl.textContent = score;
    healthEl.textContent = health;
    waveEl.textContent = wave;
  }

  function togglePause() {
    if (gameOverFlag) return;
    paused = !paused;
    pauseMsg.style.display = paused ? "block" : "none";
    if(!paused && !muted) audioCtx.resume();
  }

  function gameOver() {
    gameOverFlag = true;
    pauseMsg.style.display = "none";
    ctx.fillStyle = "white";
    ctx.font = "48px Orbitron, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 40);
    ctx.font = "24px Orbitron, sans-serif";
    ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2);
    retryBtn.style.display = "block";

    if (score > highscore) {
      localStorage.setItem("spaceHighScore", score);
      highscore = score;
      highscoreEl.textContent = highscore;
    }
  }

  retryBtn.onclick = () => {
    // Reset game state and clear game over screen
    score = 0;
    wave = 1;
    health = 3;
    gameOverFlag = false;
    retryBtn.style.display = "none";
    pauseMsg.style.display = "none";
    enemies = [];
    enemyBullets = [];
    powerUps = [];
    player.bullets = [];
    updateUI();
    spawnWave();
  };

  function update() {
    if (!paused && !gameOverFlag) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw background stars (optional cool effect)
      drawStars();

      // Border around playable area
      ctx.strokeStyle = "#0ff";
      ctx.lineWidth = 5;
      ctx.strokeRect(0, 0, canvas.width, canvas.height);

      player.update();
      player.draw();

      enemies.forEach(e => {
        e.update();
        e.draw();
      });

      enemyBullets.forEach(b => {
        b.update();
        b.draw();
      });

      powerUps.forEach(p => {
        p.update();
        p.draw();
      });

      // Bullet vs Enemy collision
      for (let b of player.bullets) {
        for (let e of enemies) {
          if (
            b.x + b.w > e.x &&
            b.x < e.x + e.w &&
            b.y + b.h > e.y &&
            b.y < e.y + e.h
          ) {
            e.hp--;
            b.y = -999; // remove bullet
            playSound(900, 'sine', 0.07, 0.06);
            if (e.hp <= 0) {
              score += e.type === "boss" ? 150 : 10;
              if (Math.random() < 0.15) {
                powerUps.push(new PowerUp(e.x + e.w / 2, e.y));
              }
              e.y = canvas.height + 99; // remove enemy
              updateUI();
            }
          }
        }
      }

      enemies = enemies.filter(e => e.y < canvas.height + 20);
      powerUps = powerUps.filter(p => p.y < canvas.height + 20);

      // Enemy bullet vs player collision
      enemyBullets = enemyBullets.filter(b => {
        if (
          b.y + b.h >= player.y &&
          b.x < player.x + player.w &&
          b.x + b.w > player.x
        ) {
          health--;
          playSound(200, 'triangle', 0.1, 0.05);
          updateUI();
          return false;
        }
        return b.y < canvas.height + 20;
      });

      // Enemy vs player collision
      for (let e of enemies) {
        if (
          e.y + e.h >= player.y &&
          e.x < player.x + player.w &&
          e.x + e.w > player.x
        ) {
          health--;
          playSound(200, 'triangle', 0.1, 0.05);
          e.hp = 0;
          updateUI();
        }
      }
      enemies = enemies.filter(e => e.hp > 0);

      // Power-up collection
      powerUps = powerUps.filter(p => {
        const dx = p.x - (player.x + player.w / 2);
        const dy = p.y - (player.y + player.h / 2);
        if (Math.sqrt(dx * dx + dy * dy) < p.r + player.w / 3) {
          player.powerUp = true;
          player.powerTime = 600; // lasts 10 seconds @60fps
          playSound(1500, 'sawtooth', 0.2, 0.08);
          return false;
        }
        return true;
      });

      // Wave progression
      if (enemies.length === 0 && waveCooldown <= 0) {
        wave++;
        waveCooldown = 90;
        spawnWave();
        updateUI();
      } else {
        waveCooldown--;
      }

      // Check game over
      if (health <= 0) {
        gameOver();
      }
    }
    requestAnimationFrame(update);
  }

  // Background stars effect
  const stars = [];
  for(let i=0; i<60; i++) {
    stars.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      size: Math.random() * 2,
      speed: 0.2 + Math.random() * 0.3
    });
  }

  function drawStars() {
    ctx.fillStyle = "#0ff";
    stars.forEach(s => {
      s.y += s.speed;
      if (s.y > canvas.height) s.y = 0;
      ctx.fillRect(s.x, s.y, s.size, s.size);
    });
  }

  // Start game
  spawnWave();
  updateUI();
  update();
</script>

</body>
</html>
