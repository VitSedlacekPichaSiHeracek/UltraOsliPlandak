<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Classic Space Shooter</title>
<style>
  body {
    margin: 0;
    background: #000;
    color: #0ff;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
    user-select: none;
  }
  #container {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding: 10px;
  }
  #gameArea {
    position: relative;
    border: 3px solid #0ff;
    background: #000;
  }
  canvas {
    display: block;
    background: #000;
  }
  #ui {
    margin-left: 20px;
    max-width: 180px;
  }
  #ui h2 {
    margin-top: 0;
    font-weight: normal;
  }
  #score, #wave, #health {
    font-size: 18px;
    margin: 10px 0;
  }
  #instructions {
    font-size: 14px;
    line-height: 1.4;
  }
  #retryBtn {
    display: none;
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 16px;
    background: #0ff;
    border: none;
    cursor: pointer;
    color: #000;
    font-weight: bold;
    border-radius: 5px;
  }
  #pauseMsg {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #0ff;
    font-size: 48px;
    font-weight: bold;
    display: none;
    pointer-events: none;
    user-select: none;
    text-shadow: 0 0 10px #0ff;
  }
</style>
</head>
<body>
<div id="container">
  <div id="gameArea">
    <canvas id="gameCanvas" width="480" height="640"></canvas>
    <div id="pauseMsg"></div>
  </div>
  <div id="ui">
    <h2>Controls</h2>
    <div id="instructions">
      ← / A: Move Left<br />
      → / D: Move Right<br />
      Space / Z: Tap to Shoot<br />
      P: Pause / Unpause
    </div>
    <div id="score">Score: 0</div>
    <div id="wave">Wave: 1</div>
    <div id="health">Health: 3</div>
    <button id="retryBtn">Retry</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const retryBtn = document.getElementById('retryBtn');
  const pauseMsg = document.getElementById('pauseMsg');
  const scoreEl = document.getElementById('score');
  const waveEl = document.getElementById('wave');
  const healthEl = document.getElementById('health');

  const keys = { left: false, right: false, shootPressed: false };
  let score = 0;
  let wave = 1;
  let health = 3;
  const maxHealth = 3;
  let paused = false;
  let gameOverFlag = false;

  // Player class
  class Player {
    constructor() {
      this.w = 36;
      this.h = 48;
      this.x = canvas.width / 2 - this.w / 2;
      this.y = canvas.height - this.h - 10;
      this.speed = 4; // slowed down from 6
      this.bullets = [];
      this.powerUp = false;
      this.powerTime = 0;
    }
    update() {
      if (keys.left) this.x -= this.speed;
      if (keys.right) this.x += this.speed;

      // Stay inside play area with border (3 px)
      if (this.x < 3) this.x = 3;
      if (this.x + this.w > canvas.width - 3) this.x = canvas.width - this.w - 3;

      // Powerup timer
      if (this.powerUp) {
        this.powerTime--;
        if (this.powerTime <= 0) this.powerUp = false;
      }

      // Update bullets
      this.bullets = this.bullets.filter(b => b.y + b.h > 0);
      this.bullets.forEach(b => b.update());
    }
    draw() {
      // Player ship shape
      ctx.fillStyle = '#0ff';
      ctx.beginPath();
      ctx.moveTo(this.x + this.w / 2, this.y);
      ctx.lineTo(this.x + this.w, this.y + this.h);
      ctx.lineTo(this.x, this.y + this.h);
      ctx.closePath();
      ctx.fill();

      // Draw bullets
      this.bullets.forEach(b => b.draw());
    }
    shoot() {
      if (this.powerUp) {
        // Triple shot (bigger bullets)
        this.bullets.push(new Bullet(this.x + this.w / 2, this.y, 10, 20));
        this.bullets.push(new Bullet(this.x + this.w / 2 - 18, this.y + 5, 8, 16, -2));
        this.bullets.push(new Bullet(this.x + this.w / 2 + 18, this.y + 5, 8, 16, 2));
      } else {
        // Single bigger bullet
        this.bullets.push(new Bullet(this.x + this.w / 2, this.y, 10, 20));
      }
      playSound(1000, 'square', 0.1, 0.1);
    }
  }

  // Bullet class
  class Bullet {
    constructor(x, y, w = 10, h = 20, dx = 0) {
      this.x = x - w / 2;
      this.y = y;
      this.w = w;
      this.h = h;
      this.speed = 10;
      this.dx = dx;
    }
    update() {
      this.y -= this.speed;
      this.x += this.dx;
    }
    draw() {
      ctx.fillStyle = '#0ff';
      ctx.beginPath();
      ctx.ellipse(this.x + this.w / 2, this.y + this.h / 2, this.w / 2, this.h / 2, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Enemy class with color by type
  class Enemy {
    constructor(x, y, speed, hp, type = 'normal') {
      this.x = x;
      this.y = y;
      this.speed = speed;
      this.hp = hp;
      this.type = type;
      this.w = 36;
      this.h = 36;
      this.color = '#fff'; // default white
      if (type === 'fast') this.color = '#0ff'; // cyan
      else if (type === 'shooter') this.color = '#f90'; // orange
      else if (type === 'boss') this.color = '#ffd700'; // gold
      this.shootTimer = 0;
    }
    update() {
      this.y += this.speed;
      // Loop back from bottom to top if no hit
      if (this.y > canvas.height) this.y = -this.h;

      // Shooters shoot occasionally
      if (this.type === 'shooter') {
        this.shootTimer--;
        if (this.shootTimer <= 0) {
          enemyBullets.push(new EnemyBullet(this.x + this.w / 2, this.y + this.h));
          this.shootTimer = 120; // shoot every ~2 sec
        }
      }
    }
    draw() {
      ctx.fillStyle = this.color;

      // Draw rounded rect enemy shape
      const r = 6;
      ctx.beginPath();
      ctx.moveTo(this.x + r, this.y);
      ctx.lineTo(this.x + this.w - r, this.y);
      ctx.quadraticCurveTo(this.x + this.w, this.y, this.x + this.w, this.y + r);
      ctx.lineTo(this.x + this.w, this.y + this.h - r);
      ctx.quadraticCurveTo(this.x + this.w, this.y + this.h, this.x + this.w - r, this.y + this.h);
      ctx.lineTo(this.x + r, this.y + this.h);
      ctx.quadraticCurveTo(this.x, this.y + this.h, this.x, this.y + this.h - r);
      ctx.lineTo(this.x, this.y + r);
      ctx.quadraticCurveTo(this.x, this.y, this.x + r, this.y);
      ctx.closePath();
      ctx.fill();

      // HP bar above enemy (for boss or hp < 5)
      if (this.type === 'boss' || this.hp < 5) {
        const barWidth = this.w;
        const barHeight = 5;
        ctx.fillStyle = '#000';
        ctx.fillRect(this.x, this.y - 10, barWidth, barHeight);
        ctx.fillStyle = '#f00';
        ctx.fillRect(this.x, this.y - 10, (this.hp / (this.type === 'boss' ? 100 : 5)) * barWidth, barHeight);
      }
    }
  }

  // Enemy bullets
  class EnemyBullet {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.speed = 6;
      this.w = 8;
      this.h = 12;
    }
    update() {
      this.y += this.speed;
    }
    draw() {
      ctx.fillStyle = '#f00';
      ctx.beginPath();
      ctx.ellipse(this.x, this.y, this.w / 2, this.h / 2, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Health regen item
  class HealthItem {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.size = 20;
      this.speed = 2;
    }
    update() {
      this.y += this.speed;
      if(this.y > canvas.height + this.size) {
        this.y = -this.size;
        this.x = Math.random() * (canvas.width - this.size);
      }
    }
    draw() {
      ctx.fillStyle = '#f44';
      ctx.beginPath();
      const topCurveHeight = this.size * 0.3;
      ctx.moveTo(this.x + this.size / 2, this.y + this.size);
      ctx.bezierCurveTo(
        this.x + this.size / 2 + this.size / 2, this.y + this.size / 2,
        this.x + this.size / 2 + this.size / 2, this.y,
        this.x + this.size / 2, this.y + topCurveHeight
      );
      ctx.bezierCurveTo(
        this.x + this.size / 2 - this.size / 2, this.y,
        this.x + this.size / 2 - this.size / 2, this.y + this.size / 2,
        this.x + this.size / 2, this.y + this.size
      );
      ctx.closePath();
      ctx.fill();
    }
  }

  // Stars for background
  class Star {
    constructor() {
      this.x = Math.random() * canvas.width;
      this.y = Math.random() * canvas.height;
      this.size = Math.random() * 2 + 1;
      this.speed = this.size * 0.3;
    }
    update() {
      this.y += this.speed;
      if (this.y > canvas.height) {
        this.y = 0;
        this.x = Math.random() * canvas.width;
      }
    }
    draw() {
      ctx.fillStyle = '#0ff';
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Globals
  const player = new Player();
  let enemies = [];
  let enemyBullets = [];
  let healthItems = [];
  let stars = [];
  let spawnTimer = 0;

  // Initialize stars
  for (let i = 0; i < 60; i++) stars.push(new Star());

  // Setup wave enemies
  function spawnWave(waveNum) {
    enemies = [];
    enemyBullets = [];
    healthItems = [];

    const baseSpeed = 1 + waveNum * 0.1;

    // Normal enemies (white)
    for (let i = 0; i < 8 + waveNum * 2; i++) {
      enemies.push(new Enemy(
        Math.random() * (canvas.width - 36),
        -Math.random() * 600,
        baseSpeed + Math.random() * 0.5,
        3,
        'normal'
      ));
    }

    // Fast enemies (cyan)
    for (let i = 0; i < Math.min(3, waveNum); i++) {
      enemies.push(new Enemy(
        Math.random() * (canvas.width - 36),
        -Math.random() * 600,
        baseSpeed + 1.5 + Math.random(),
        2,
        'fast'
      ));
    }

    // Shooters (orange) from wave 3+
    if (waveNum >= 3) {
      for (let i = 0; i < waveNum; i++) {
        enemies.push(new Enemy(
          Math.random() * (canvas.width - 36),
          -Math.random() * 600,
          baseSpeed,
          4,
          'shooter'
        ));
      }
    }

    // Boss every 5 waves (gold)
    if (waveNum % 5 === 0) {
      enemies.push(new Enemy(
        canvas.width / 2 - 50,
        -120,
        0,
        100,
        'boss'
      ));
    }
  }

  // Sound helper
  function playSound(freq, type='square', volume=0.1, duration=0.1) {
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      const audioCtx = new AudioContext();
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();

      oscillator.type = type;
      oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
      gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);

      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      oscillator.start();
      oscillator.stop(audioCtx.currentTime + duration);

      oscillator.onended = () => audioCtx.close();
    } catch (e) {
      // no audio
    }
  }

  // Rect collision detection
  function rectsCollide(a, b) {
    return a.x < b.x + b.w &&
           a.x + a.w > b.x &&
           a.y < b.y + b.h &&
           a.y + a.h > b.y;
  }

  // On enemy hit
  function onEnemyHit(enemy) {
    enemy.hp--;
    if (enemy.hp <= 0) {
      score += enemy.type === 'boss' ? 1000 : 100;
      playSound(800, 'triangle', 0.12, 0.2);
      // Chance for health drop (5%)
      if(Math.random() < 0.05) {
        healthItems.push(new HealthItem(enemy.x + enemy.w/2 - 10, enemy.y + enemy.h));
      }
      // Remove enemy
      enemies.splice(enemies.indexOf(enemy), 1);
    } else {
      playSound(600, 'square', 0.06, 0.1);
    }
  }

  // Main game loop
  function loop() {
    if (paused || gameOverFlag) return;

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw background stars
    stars.forEach(s => {
      s.update();
      s.draw();
    });

    // Update & draw player
    player.update();
    player.draw();

    // Update & draw enemies
    enemies.forEach(e => {
      e.update();
      e.draw();
    });

    // Update & draw enemy bullets
    enemyBullets.forEach(b => {
      b.update();
      b.draw();
    });

    // Update & draw health items
    healthItems.forEach(item => {
      item.update();
      item.draw();
    });

    // Collision detection: player bullets vs enemies
    player.bullets.forEach(bullet => {
      enemies.forEach(enemy => {
        if (rectsCollide(
          {x: bullet.x, y: bullet.y, w: bullet.w, h: bullet.h},
          {x: enemy.x, y: enemy.y, w: enemy.w, h: enemy.h}
        )) {
          onEnemyHit(enemy);
          bullet.y = -1000; // remove bullet by putting offscreen
        }
      });
    });

    // Collision detection: enemy bullets vs player
    enemyBullets.forEach(bullet => {
      if (rectsCollide(
        {x: bullet.x - bullet.w/2, y: bullet.y - bullet.h/2, w: bullet.w, h: bullet.h},
        {x: player.x, y: player.y, w: player.w, h: player.h}
      )) {
        health--;
        playSound(200, 'sawtooth', 0.25, 0.15);
        bullet.y = canvas.height + 1000; // remove bullet offscreen
        updateUI();
        if(health <= 0) gameOver();
      }
    });

    // Collision detection: player vs health items
    healthItems.forEach((item, i) => {
      if (rectsCollide(
        {x: item.x, y: item.y, w: item.size, h: item.size},
        {x: player.x, y: player.y, w: player.w, h: player.h}
      )) {
        health = maxHealth;
        playSound(900, 'triangle', 0.15, 0.3);
        healthItems.splice(i, 1);
        updateUI();
      }
    });

    // Check if wave cleared
    if (enemies.length === 0) {
      wave++;
      player.powerUp = true;
      player.powerTime = 600; // ~10 seconds triple shot
      spawnWave(wave);
      updateUI();
    }

    updateUI();

    requestAnimationFrame(loop);
  }

  // Update UI text
  function updateUI() {
    scoreEl.textContent = `Score: ${score}`;
    waveEl.textContent = `Wave: ${wave}`;
    healthEl.textContent = `Health: ${health}`;
  }

  // Game over
  function gameOver() {
    gameOverFlag = true;
    pauseMsg.textContent = 'GAME OVER';
    pauseMsg.style.display = 'block';
    retryBtn.style.display = 'block';
  }

  // Reset game state
  function resetGame() {
    score = 0;
    wave = 1;
    health = maxHealth;
    gameOverFlag = false;
    pauseMsg.style.display = 'none';
    retryBtn.style.display = 'none';
    player.x = canvas.width / 2 - player.w / 2;
    player.bullets = [];
    player.powerUp = false;
    player.powerTime = 0;
    enemies = [];
    enemyBullets = [];
    healthItems = [];
    spawnWave(wave);
    updateUI();
    loop();
  }

  // Input listeners
  window.addEventListener('keydown', e => {
    if (e.repeat) return;
    switch(e.key.toLowerCase()) {
      case 'arrowleft':
      case 'a':
        keys.left = true;
        break;
      case 'arrowright':
      case 'd':
        keys.right = true;
        break;
      case ' ':
      case 'z':
        if (!keys.shootPressed) {
          player.shoot();
          keys.shootPressed = true;
        }
        break;
      case 'p':
        paused = !paused;
        if (!paused && !gameOverFlag) {
          pauseMsg.style.display = 'none';
          loop();
        } else if (paused) {
          pauseMsg.textContent = 'PAUSED';
          pauseMsg.style.display = 'block';
        }
        break;
    }
  });
  window.addEventListener('keyup', e => {
    switch(e.key.toLowerCase()) {
      case 'arrowleft':
      case 'a':
        keys.left = false;
        break;
      case 'arrowright':
      case 'd':
        keys.right = false;
        break;
      case ' ':
      case 'z':
        keys.shootPressed = false;
        break;
    }
  });

  // Retry button click
  retryBtn.onclick = () => {
    resetGame();
  };

  // Start the game
  resetGame();
})();
</script>
</body>
</html>
