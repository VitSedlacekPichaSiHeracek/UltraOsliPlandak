<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üöÄ Space Shooter Deluxe</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #000;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
      color: white;
    }
    canvas {
      display: block;
      margin: auto;
      border: 5px solid #00ffcc;
      background: radial-gradient(ellipse at center, #000 0%, #030303 100%);
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      font-size: 18px;
      color: #0ff;
      text-shadow: 1px 1px 2px #000;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div>üöÄ Score: <span id="score">0</span></div>
    <div>‚ù§Ô∏è Health: <span id="health">3</span></div>
    <div>üåä Wave: <span id="wave">1</span></div>
    <div>üèÜ High Score: <span id="highscore">0</span></div>
  </div>
  <canvas id="game" width="480" height="640"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const keys = {};
    document.addEventListener("keydown", e => keys[e.key] = true);
    document.addEventListener("keyup", e => keys[e.key] = false);

    let score = 0, wave = 1, health = 3;
    let highscore = localStorage.getItem("spaceHighScore") || 0;
    document.getElementById("highscore").textContent = highscore;

    class Player {
      constructor() {
        this.w = 32;
        this.h = 26;
        this.x = canvas.width / 2 - this.w / 2;
        this.y = canvas.height - 60;
        this.speed = 2.5;
        this.cooldown = 0;
        this.bullets = [];
        this.powerUp = false;
        this.powerTime = 0;
      }
      update() {
        if (keys["ArrowLeft"] && this.x > 0) this.x -= this.speed;
        if (keys["ArrowRight"] && this.x + this.w < canvas.width) this.x += this.speed;
        if (keys[" "] || keys["z"]) this.shoot();
        if (this.cooldown > 0) this.cooldown--;

        this.bullets.forEach(b => b.update());
        this.bullets = this.bullets.filter(b => b.y > -20);

        if (this.powerUp && --this.powerTime <= 0) this.powerUp = false;
      }
      draw() {
        ctx.fillStyle = this.powerUp ? "#ff0" : "#0ff";
        ctx.beginPath();
        ctx.moveTo(this.x + this.w / 2, this.y);
        ctx.lineTo(this.x, this.y + this.h);
        ctx.lineTo(this.x + this.w, this.y + this.h);
        ctx.closePath();
        ctx.fill();
        this.bullets.forEach(b => b.draw());
      }
      shoot() {
        if (this.cooldown <= 0) {
          this.bullets.push(new Bullet(this.x + this.w / 2, this.y));
          if (this.powerUp) {
            this.bullets.push(new Bullet(this.x + 5, this.y, -1));
            this.bullets.push(new Bullet(this.x + this.w - 5, this.y, 1));
          }
          this.cooldown = this.powerUp ? 5 : 12;
        }
      }
    }

    class Bullet {
      constructor(x, y, dx = 0) {
        this.x = x;
        this.y = y;
        this.r = 3;
        this.speed = 5;
        this.dx = dx;
      }
      update() {
        this.y -= this.speed;
        this.x += this.dx;
      }
      draw() {
        ctx.fillStyle = "#ff0";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class Enemy {
      constructor(x, y, speed, hp, type = "normal") {
        this.x = x;
        this.y = y;
        this.w = 30;
        this.h = 20;
        this.speed = speed;
        this.hp = hp;
        this.type = type;
        this.dir = Math.random() < 0.5 ? -1 : 1;
      }
      update() {
        this.y += this.speed;
        this.x += this.dir * 0.3;
        if (this.x < 0 || this.x + this.w > canvas.width) this.dir *= -1;
      }
      draw() {
        ctx.fillStyle = this.type === "boss" ? "#f00" : "#0f0";
        ctx.fillRect(this.x, this.y, this.w, this.h);
      }
    }

    class PowerUp {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.r = 8;
        this.speed = 1.5;
      }
      update() {
        this.y += this.speed;
      }
      draw() {
        ctx.fillStyle = "#ff0";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    const player = new Player();
    let enemies = [];
    let powerUps = [];
    let waveCooldown = 0;

    function spawnWave() {
      enemies = [];
      const count = 6 + wave * 2;
      for (let i = 0; i < count; i++) {
        const x = Math.random() * (canvas.width - 30);
        const y = -Math.random() * 300;
        enemies.push(new Enemy(x, y, 0.6 + wave * 0.15, 1));
      }
      if (wave % 5 === 0) {
        enemies.push(new Enemy(canvas.width / 2 - 30, -100, 1, 20, "boss"));
      }
    }

    function updateUI() {
      document.getElementById("score").textContent = score;
      document.getElementById("health").textContent = health;
      document.getElementById("wave").textContent = wave;
    }

    function update() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      player.update();
      player.draw();

      enemies.forEach(e => e.update());
      enemies.forEach(e => e.draw());

      powerUps.forEach(p => p.update());
      powerUps.forEach(p => p.draw());

      // Bullet vs Enemy
      for (let b of player.bullets) {
        for (let e of enemies) {
          if (b.x > e.x && b.x < e.x + e.w && b.y > e.y && b.y < e.y + e.h) {
            e.hp--;
            b.y = -999;
            if (e.hp <= 0) {
              score += e.type === "boss" ? 100 : 10;
              if (Math.random() < 0.1) {
                powerUps.push(new PowerUp(e.x + e.w / 2, e.y));
              }
              e.y = canvas.height + 99;
              updateUI();
            }
          }
        }
      }

      enemies = enemies.filter(e => e.y < canvas.height + 20);
      powerUps = powerUps.filter(p => p.y < canvas.height + 20);

      // Enemy vs Player
      for (let e of enemies) {
        if (
          e.y + e.h >= player.y &&
          e.x < player.x + player.w &&
          e.x + e.w > player.x
        ) {
          health--;
          e.y = canvas.height + 100;
          if (health <= 0) return gameOver();
          updateUI();
        }
      }

      // PowerUp collection
      powerUps = powerUps.filter(p => {
        if (
          p.y + p.r > player.y &&
          p.x > player.x &&
          p.x < player.x + player.w
        ) {
          player.powerUp = true;
          player.powerTime = 400;
          return false;
        }
        return true;
      });

      if (enemies.length === 0 && waveCooldown <= 0) {
        wave++;
        waveCooldown = 60;
        updateUI();
      }
      if (waveCooldown > 0 && --waveCooldown === 0) spawnWave();

      requestAnimationFrame(update);
    }

    function gameOver() {
      ctx.fillStyle = "white";
      ctx.font = "32px Orbitron, sans-serif";
      ctx.fillText("GAME OVER", canvas.width / 2 - 100, canvas.height / 2);
      if (score > highscore) {
        localStorage.setItem("spaceHighScore", score);
        document.getElementById("highscore").textContent = score;
      }
    }

    spawnWave();
    updateUI();
    update();
  </script>
</body>
</html>
