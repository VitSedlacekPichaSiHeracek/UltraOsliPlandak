<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Classic Space Shooter</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');
  body {
    margin: 0; 
    background: #000;
    color: #0ff;
    font-family: 'Orbitron', sans-serif;
    overflow: hidden;
    user-select: none;
  }
  #gameContainer {
    position: relative;
    margin: auto;
    width: 480px;
    height: 640px;
    border: 5px solid #0ff;
    background: #000;
  }
  canvas {
    display: block;
    background: #000;
  }
  #ui {
    position: absolute;
    top: 8px;
    right: 8px;
    color: #0ff;
    font-size: 16px;
    text-align: right;
    user-select: none;
  }
  #instructions {
    position: absolute;
    top: 80px;
    right: 8px;
    font-size: 14px;
    max-width: 140px;
    line-height: 1.3;
  }
  #pauseMsg {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 48px;
    color: #0ff;
    display: none;
    pointer-events: none;
  }
  #retryBtn {
    position: absolute;
    top: 55%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 22px;
    padding: 10px 24px;
    background: #0ff;
    color: #000;
    border: none;
    cursor: pointer;
    display: none;
    user-select: none;
    border-radius: 6px;
  }
  #retryBtn:hover {
    background: #0cc;
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="game" width="480" height="640"></canvas>
  <div id="ui">
    <div>Score: <span id="score">0</span></div>
    <div>Health: <span id="health">3</span></div>
    <div>Wave: <span id="wave">1</span></div>
  </div>
  <div id="instructions">
    Controls:<br>
    ← / →: Move<br>
    Space or Z: Tap to shoot<br>
    P: Pause<br>
  </div>
  <div id="pauseMsg">PAUSED</div>
  <button id="retryBtn">Retry</button>
</div>

<script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const scoreEl = document.getElementById('score');
  const healthEl = document.getElementById('health');
  const waveEl = document.getElementById('wave');
  const pauseMsg = document.getElementById('pauseMsg');
  const retryBtn = document.getElementById('retryBtn');

  let score = 0;
  let health = 3;
  let wave = 1;
  let paused = false;
  let gameOverFlag = false;

  // Input
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if(e.code === 'KeyP') togglePause();
    if(gameOverFlag && e.code === 'Space') retryBtn.click();
  });
  window.addEventListener('keyup', e => keys[e.code] = false);

  // Sound helper
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  function playSound(freq, type='square', vol=0.05, duration=0.1) {
    if(paused || gameOverFlag) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.value = vol;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
  }

  // Background music: simple 8bit arpeggio (loops)
  const melody = [523, 659, 784, 1046];
  let melodyIndex = 0;
  setInterval(() => {
    if(!paused && !gameOverFlag) {
      playSound(melody[melodyIndex], 'square', 0.03, 0.15);
      melodyIndex = (melodyIndex + 1) % melody.length;
    }
  }, 300);

  // Player class
  class Player {
    constructor() {
      this.w = 38;
      this.h = 44;
      this.x = canvas.width / 2 - this.w / 2;
      this.y = canvas.height - this.h - 10;
      this.speed = 3.5;
      this.bullets = [];
      this.cooldown = 0;
      this.powerUp = false;
      this.powerTime = 0;
    }
    update() {
      if (paused || gameOverFlag) return;
      if (keys['ArrowLeft'] || keys['KeyA']) this.x -= this.speed;
      if (keys['ArrowRight'] || keys['KeyD']) this.x += this.speed;

      // Keep inside bounds
      if (this.x < 0) this.x = 0;
      if (this.x + this.w > canvas.width) this.x = canvas.width - this.w;

      if (this.cooldown > 0) this.cooldown--;

      // Tap to shoot only (no hold)
      if ((keys['Space'] || keys['KeyZ']) && this.cooldown === 0) {
        this.shoot();
      }

      // Power-up timer countdown
      if(this.powerUp) {
        this.powerTime--;
        if(this.powerTime <= 0) this.powerUp = false;
      }

      this.bullets.forEach(b => b.update());
      this.bullets = this.bullets.filter(b => b.y + b.h > 0);
    }
    draw() {
      // Ship shape
      ctx.fillStyle = "#0ff";
      ctx.beginPath();
      ctx.moveTo(this.x + this.w / 2, this.y);
      ctx.lineTo(this.x, this.y + this.h);
      ctx.lineTo(this.x + this.w, this.y + this.h);
      ctx.closePath();
      ctx.fill();

      // cockpit window
      ctx.fillStyle = "#003344";
      ctx.beginPath();
      ctx.moveTo(this.x + this.w / 2, this.y + 8);
      ctx.lineTo(this.x + 10, this.y + this.h - 5);
      ctx.lineTo(this.x + this.w - 10, this.y + this.h - 5);
      ctx.closePath();
      ctx.fill();

      this.bullets.forEach(b => b.draw());
    }
    shoot() {
      if (this.cooldown === 0 && !gameOverFlag) {
        const bulletW = 10;  // bigger bullets now
        const bulletH = 18;
        const bulletSpeed = 5;

        // Triple shot
        this.bullets.push(new Bullet(this.x + this.w / 2 - bulletW / 2, this.y - bulletH, bulletW, bulletH, bulletSpeed));
        this.bullets.push(new Bullet(this.x + this.w / 2 - bulletW / 2 - 15, this.y - bulletH, bulletW, bulletH, bulletSpeed));
        this.bullets.push(new Bullet(this.x + this.w / 2 - bulletW / 2 + 15, this.y - bulletH, bulletW, bulletH, bulletSpeed));

        this.cooldown = 25; // fixed cooldown for tap shooting
        playSound(1100, 'square', 0.06, 0.05);
      }
    }
  }

  class Bullet {
    constructor(x, y, w, h, speed) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      this.speed = speed;
    }
    update() {
      this.y -= this.speed;
    }
    draw() {
      ctx.fillStyle = "#0ff";
      ctx.fillRect(this.x, this.y, this.w, this.h);
    }
  }

  class Enemy {
    constructor(x, y, speed, hp, type = "normal") {
      this.x = x;
      this.y = y;
      this.w = 34;
      this.h = 22;
      this.speed = speed;
      this.hp = hp;
      this.type = type;
      this.dir = Math.random() < 0.5 ? -1 : 1;
      this.moveTimer = 0;
      this.shootCooldown = 0;
    }
    update() {
      if (paused || gameOverFlag) return;

      if (this.type === "fast") {
        this.y += this.speed * 1.8;
        this.x += this.dir * 1;
        this.moveTimer++;
        if(this.moveTimer % 30 === 0) this.dir *= -1;
      } else if (this.type === "shooter") {
        this.y += this.speed * 0.8;
        this.moveTimer++;
        if(this.moveTimer % 50 === 0) this.dir *= -1;
        this.x += this.dir * 0.5;
        this.shootCooldown--;
        if(this.shootCooldown <= 0) {
          enemyBullets.push(new EnemyBullet(this.x + this.w / 2 - 4, this.y + this.h, 8, 12, 3));
          this.shootCooldown = 120;
          playSound(300, 'triangle', 0.05, 0.03);
        }
      } else if (this.type === "boss") {
        this.y += this.speed * 0.4;
        this.moveTimer++;
        if(this.moveTimer % 20 === 0) this.dir *= -1;  // zigzag
        this.x += this.dir * 0.4;
      } else {
        // normal
        this.y += this.speed;
        this.moveTimer++;
        if(this.moveTimer % 30 === 0) this.dir *= -1;  // zigzag
        this.x += this.dir * 0.4;
      }

      // Stay in bounds horizontally
      if (this.x < 0) this.x = 0;
      if (this.x + this.w > canvas.width) this.x = canvas.width - this.w;

      // Loop enemies that pass bottom back to top at random x
      if (this.y > canvas.height) {
        this.y = -this.h - Math.random() * 150;
        this.x = Math.random() * (canvas.width - this.w);
      }
    }
    draw() {
      if(this.type === "boss") {
        ctx.fillStyle = "#f00";
        ctx.beginPath();
        ctx.moveTo(this.x + this.w / 2, this.y);
        ctx.lineTo(this.x, this.y + this.h);
        ctx.lineTo(this.x + this.w, this.y + this.h);
        ctx.closePath();
        ctx.fill();
        // Boss eye
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(this.x + this.w / 2, this.y + this.h * 0.5, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(this.x + this.w / 2, this.y + this.h * 0.5, 2, 0, Math.PI * 2);
        ctx.fill();
      } else if (this.type === "fast") {
        ctx.fillStyle = "#f90";
        ctx.beginPath();
        ctx.ellipse(this.x + this.w / 2, this.y + this.h / 2, this.w / 2, this.h / 2, 0, 0, Math.PI * 2);
        ctx.fill();
      } else if (this.type === "shooter") {
        ctx.fillStyle = "#f0f";
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + this.w / 2, this.y + this.h);
        ctx.lineTo(this.x + this.w, this.y);
        ctx.closePath();
        ctx.fill();
      } else {
        ctx.fillStyle = "#0f0";
        ctx.beginPath();
        ctx.moveTo(this.x + this.w / 2, this.y);
        ctx.lineTo(this.x, this.y + this.h);
        ctx.lineTo(this.x + this.w, this.y + this.h);
        ctx.closePath();
        ctx.fill();
      }
    }
  }

  class EnemyBullet {
    constructor(x, y, w, h, speed) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      this.speed = speed;
    }
    update() {
      this.y += this.speed;
    }
    draw() {
      ctx.fillStyle = "#f00";
      ctx.fillRect(this.x, this.y, this.w, this.h);
    }
  }

  // Power-ups: normal star and new health regen heart
  class PowerUp {
    constructor(x, y, type="weapon") {
      this.x = x;
      this.y = y;
      this.speed = 1.5;
      this.angle = 0;
      this.type = type; // "weapon" or "health"
    }
    update() {
      if(paused || gameOverFlag) return;
      this.y += this.speed;
      this.angle += 0.1;
    }
    draw() {
      if(this.type === "weapon") {
        // simple star shape
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = "#0ff";
        ctx.beginPath();
        for(let i=0; i<5; i++) {
          ctx.lineTo(0, 10);
          ctx.translate(0, 10);
          ctx.rotate((Math.PI * 2 / 10));
          ctx.lineTo(0, -10);
          ctx.translate(0, -10);
          ctx.rotate(-(Math.PI * 6 / 10));
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      } else if(this.type === "health") {
        // heart shape
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.fillStyle = "#ff0";
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(0, -6, 6, -6, 6, 0);
        ctx.bezierCurveTo(6, 6, 0, 10, 0, 14);
        ctx.bezierCurveTo(0, 10, -6, 6, -6, 0);
        ctx.bezierCurveTo(-6, -6, 0, -6, 0, 0);
        ctx.fill();
        ctx.restore();
      }
    }
  }

  // Globals
  const player = new Player();
  let enemies = [];
  let enemyBullets = [];
  let powerUps = [];
  let waveCooldown = 0;

  function spawnWave() {
    enemies = [];
    enemyBullets = [];
    powerUps = [];
    const count = 4 + wave;
    for(let i = 0; i < count; i++) {
      let x = 40 + i * 100;
      let y = -Math.random() * 300;
      let type = "normal";
      if(wave >= 5 && i === 0) type = "boss";
      else if(Math.random() < 0.15) type = "shooter";
      else if(Math.random() < 0.4) type = "fast";

      let hp = type === "boss" ? 12 : 1;
      enemies.push(new Enemy(x, y, 1 + wave*0.15, hp, type));
    }
  }

  function updateUI() {
    scoreEl.textContent = score;
    healthEl.textContent = health;
    waveEl.textContent = wave;
  }

  function gameOver() {
    gameOverFlag = true;
    retryBtn.style.display = "block";
  }

  function togglePause() {
    if(gameOverFlag) return;
    paused = !paused;
    pauseMsg.style.display = paused ? 'block' : 'none';
  }

  retryBtn.onclick = () => {
    score = 0;
    health = 3;
    wave = 1;
    gameOverFlag = false;
    paused = false;
    retryBtn.style.display = "none";
    player.bullets = [];
    enemyBullets = [];
    powerUps = [];
    spawnWave();
    updateUI();
  };

  // Collision helper
  function rectsCollide(a, b) {
    return !(b.x > a.x + a.w || 
             b.x + b.w < a.x || 
             b.y > a.y + a.h ||
             b.y + b.h < a.y);
  }

  // Main update loop
  function update() {
    if(paused || gameOverFlag) {
      draw();
      requestAnimationFrame(update);
      return;
    }

    // Update player
    player.update();

    // Update enemies and enemy bullets
    enemies.forEach(e => e.update());
    enemyBullets.forEach(b => b.update());

    // Remove enemy bullets off screen
    enemyBullets = enemyBullets.filter(b => b.y < canvas.height);

    // Update power-ups
    powerUps.forEach(p => p.update());

    // Bullet vs enemy collisions
    player.bullets.forEach((b) => {
      enemies.forEach((e) => {
        if(rectsCollide(b, e)) {
          e.hp--;
          playSound(800, 'triangle', 0.08, 0.05);
          if(e.hp <= 0) {
            score += e.type === "boss" ? 50 : 10;
            // 20% chance to drop power-up
            if(Math.random() < 0.2) {
              const type = Math.random() < 0.3 ? "health" : "weapon";
              powerUps.push(new PowerUp(e.x + e.w/2, e.y + e.h/2, type));
            }
            e.hp = 0;
          }
          b.y = -1000; // remove bullet after hit
        }
      });
    });

    // Enemy bullets vs player
    enemyBullets.forEach((b) => {
      if(rectsCollide(b, player)) {
        health--;
        playSound(200, 'triangle', 0.1, 0.05);
        b.y = canvas.height + 10;
      }
    });
    enemyBullets = enemyBullets.filter(b => b.y < canvas.height);

    // Enemies vs player collision
    enemies.forEach((e) => {
      if(rectsCollide(e, player)) {
        health--;
        playSound(200, 'triangle', 0.1, 0.05);
        e.hp = 0;
      }
    });

    enemies = enemies.filter(e => e.hp > 0);

    // Power-up collection
    powerUps = powerUps.filter(p => {
      const dx = p.x - (player.x + player.w / 2);
      const dy = p.y - (player.y + player.h / 2);
      const dist = Math.sqrt(dx * dx + dy * dy);
      if(dist < 25) {
        if(p.type === "weapon") {
          player.powerUp = true;
          player.powerTime = 600;
          playSound(1500, 'sawtooth', 0.2, 0.08);
        } else if(p.type === "health") {
          health = 3;
          playSound(1000, 'triangle', 0.15, 0.1);
        }
        return false;
      }
      return true;
    });

    // Wave progression
    if(enemies.length === 0 && waveCooldown <= 0) {
      wave++;
      waveCooldown = 90;
      spawnWave();
      updateUI();
    } else {
      waveCooldown--;
    }

    // Check game over
    if(health <= 0) {
      health = 0;
      updateUI();
      gameOver();
    }

    updateUI();
    draw();
    requestAnimationFrame(update);
  }

  // Draw everything
  function draw() {
    // Clear
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Border
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 5;
    ctx.strokeRect(0, 0, canvas.width, canvas.height);

    // Draw stars background
    drawStars();

    // Player
    player.draw();

    // Enemies
    enemies.forEach(e => e.draw());

    // Enemy bullets
    enemyBullets.forEach(b => b.draw());

    // Power-ups
    powerUps.forEach(p => p.draw());

    if(paused) {
      pauseMsg.style.display = 'block';
    } else {
      pauseMsg.style.display = 'none';
    }

    if(gameOverFlag) {
      ctx.fillStyle = "#0ff";
      ctx.font = "48px Orbitron, monospace";
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 40);
      ctx.font = "24px Orbitron, monospace";
      ctx.fillText("Press Retry to Play Again", canvas.width / 2, canvas.height / 2 + 20);
    }
  }

  // Background stars effect
  const stars = [];
  for(let i=0; i<60; i++) {
    stars.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      size: Math.random() * 2,
      speed: 0.2 + Math.random() * 0.3
    });
  }
  function drawStars() {
    ctx.fillStyle = "#0ff";
    stars.forEach(s => {
      s.y += s.speed;
      if(s.y > canvas.height) s.y = 0;
      ctx.fillRect(s.x, s.y, s.size, s.size);
    });
  }

  spawnWave();
  updateUI();
  update();
</script>
</body>
</html>
